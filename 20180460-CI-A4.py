# -*- coding: utf-8 -*-
"""20180460_CI_A4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ND1lrA_gF9uu1KLDmzNZ4KA-QmWi7vVX
"""

import matplotlib.pyplot as plt
import numpy as np

# Variables:
    # x_id: Refers to particle's position.
    # v_id: Refers to Particle's Velocity.
    # pop_size: Refers to population size.
    # dim: Refers to number of dimensions.
    # x_fitness: Refers to the particle's current position.
    # p_i: Refers to the particle's best position.
    # particle_bestFit: Refers to the particle's best position.
    # p_g: Refers to the best population for all.
    # global_bestFit: Refers to the best population for all.
    # Cognitive: Refers to particle own best position.
    # Social: Refers to the best position found by the particleâ€™s neighborhood.
    # numItr: Refers to number of iteration (Stopping Criteria).



# initiating population
def intiate_population(pop_size, x_max, x_min, v_max, dim):
    
    x_id = np.zeros((pop_size, dim), dtype=float)
    v_id = np.zeros((pop_size, dim), dtype=float)
    
    for i in range(dim):
        x_id[:, i] = np.random.uniform(x_min[i], x_max[i], (pop_size))
        v_id[:, i] = np.random.uniform((-1 * v_max[i]), v_max[i], (pop_size))
    return x_id, v_id

# Fitness calculatoin using the given obj f
def Fitness_clalculation(x_i):  

    fitness = np.sin(2 * x_i[0] - (0.5 * np.pi)) + 3 * np.cos(x_i[1]) + (0.5 * x_i[0])
    return fitness

# Best Particle updating
def Best_particle_upadte(x_i, x_fitness, p_i, particle_bestFit):  

    if x_fitness > particle_bestFit:
        p_i = x_i

    return p_i

# Updating the best position in the population and the best fitness in the population
def updatePgd(p_i, particle_bestFit, p_g, global_bestFit):  

    if particle_bestFit > global_bestFit:
        p_g = p_i
        global_bestFit = particle_bestFit

    return p_g, global_bestFit

# Calculating the particle's new velocity and position
def VelocityANDpos_update(p_i, p_g, x_i, v_i, Cognitive, Social, dim):  

    r_cog = np.random.random(dim)
    r_soc = np.random.random(dim)
    v_i = np.array(v_i) + (Cognitive * np.multiply(r_cog, np.subtract(p_i, x_i))) + (
                Social * np.multiply(r_soc, np.subtract(p_g, x_i)))
    x_i = np.array(x_i) + v_i

    return x_i, v_i


def Particle_Swarm_optimization(numItr, pop_size, x_max, x_min, v_max, dim, Cognitive, Social):
    x, v = intiate_population(pop_size, x_max, x_min, v_max, dim)
    p = x[:]
    p_g = np.zeros(dim)
    global_bestFit = -9999999

    for iteration in range(numItr):

        for i in range(pop_size):
            p[i] = Best_particle_upadte(x[i], Fitness_clalculation(x[i]), p[i], Fitness_clalculation(p[i]))
            p_g, global_bestFit = updatePgd(p[i], Fitness_clalculation(p[i]), p_g, global_bestFit)

        for i in range(pop_size):
            x[i], v[i] = VelocityANDpos_update(p[i], p_g, x[i], v[i], Cognitive, Social, dim)
        plt.scatter(x[0], x[1])
    plt.show()

    return p_g, global_bestFit

numItr = 200
pop_size = 50
x_max = [3, 1]
x_min = [-2, -2]
v_max = [-0.1, 0.1]
dim = 2
Cognitive = 1.7
Social = 1.7

p_g, global_bestFit = Particle_Swarm_optimization(numItr, pop_size, x_max, x_min, v_max, dim, Cognitive, Social)

print(p_g)
global_bestFit